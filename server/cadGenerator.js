// =============================================================================
// cadGenerator.js — Converts a structured JSON design plan into OpenSCAD code.
//
// Every function is parametrically driven by the plan dimensions so the
// generated SCAD is dimensionally accurate for any input.
// =============================================================================

/**
 * Port dimension lookup table (width × height in mm).
 * Used to cut accurate openings in enclosure walls.
 */
const PORT_DIMENSIONS = {
    usb: { w: 12, h: 7 },
    micro_usb: { w: 8, h: 3.5 },
    usb_c: { w: 9.5, h: 3.5 },
    power: { w: 9, h: 11 },
    hdmi: { w: 15, h: 6 },
    ethernet: { w: 16, h: 14 },
    audio_jack: { w: 7, h: 7 },  // treated as square cutout
    sd_card: { w: 13, h: 3 },
    generic_cutout: { w: 12, h: 10 },
};

// ---------------------------------------------------------------------------
// Main entry point
// ---------------------------------------------------------------------------
function generateSCAD(plan) {
    const {
        dimensions,
        wall_thickness: wall,
        ports,
        vents,
        screw_posts,
        lid_type,
    } = plan;

    const { length, width, height } = dimensions;
    const clearance = 0.5;

    // Outer dimensions of the box shell
    const outerL = length + wall * 2;
    const outerW = width + wall * 2;
    const outerH = height + wall; // open-topped box

    const lines = [];
    const push = (s) => lines.push(s);

    // ── Header ──────────────────────────────────────────────────────────────
    push(`// =============================================`);
    push(`// Generated by EnclosureAI`);
    push(`// Enclosure: ${plan.case_type}`);
    push(`// Dims (inner): ${length} × ${width} × ${height} mm`);
    push(`// =============================================`);
    push(`$fn = 48;`);
    push(``);

    // ── Global parameters ──────────────────────────────────────────────────
    push(`// ----- Parameters -----`);
    push(`inner_l   = ${length};`);
    push(`inner_w   = ${width};`);
    push(`inner_h   = ${height};`);
    push(`wall      = ${wall};`);
    push(`clearance = ${clearance};`);
    push(`outer_l   = inner_l + wall * 2;`);
    push(`outer_w   = inner_w + wall * 2;`);
    push(`outer_h   = inner_h + wall;`);
    push(``);

    // ── create_box module ──────────────────────────────────────────────────
    push(`// ----- Main Enclosure Box -----`);
    push(`module create_box() {`);
    push(`  difference() {`);
    push(`    // Outer shell`);
    push(`    cube([outer_l, outer_w, outer_h]);`);
    push(``);
    push(`    // Inner cavity`);
    push(`    translate([wall, wall, wall])`);
    push(`      cube([inner_l, inner_w, inner_h + 1]);`);
    push(``);

    // Port cutouts inline inside the box difference
    if (ports && ports.length > 0) {
        push(`    // ----- Port cutouts -----`);
        ports.forEach((port, i) => {
            const dim = PORT_DIMENSIONS[port.type] || PORT_DIMENSIONS.generic_cutout;
            const pos = port.position ?? length / 2;
            const hOff = port.height_offset ?? 3;
            const cutDepth = wall + 2; // cut cleanly through the wall

            push(`    // Port ${i}: ${port.type} on ${port.side}`);

            switch (port.side) {
                case "front": {
                    // Front wall sits at Y = 0
                    const cx = wall + pos - dim.w / 2;
                    const cy = -1; // penetrate outer surface
                    const cz = wall + hOff;
                    push(`    translate([${cx}, ${cy}, ${cz}])`);
                    push(`      cube([${dim.w}, ${cutDepth}, ${dim.h}]);`);
                    break;
                }
                case "back": {
                    // Back wall sits at Y = outerW - wall
                    const cx = wall + pos - dim.w / 2;
                    const cy = outerW - wall - 1;
                    const cz = wall + hOff;
                    push(`    translate([${cx}, ${cy}, ${cz}])`);
                    push(`      cube([${dim.w}, ${cutDepth}, ${dim.h}]);`);
                    break;
                }
                case "left": {
                    // Left wall sits at X = 0
                    const cx = -1;
                    const cy = wall + pos - dim.w / 2;
                    const cz = wall + hOff;
                    push(`    translate([${cx}, ${cy}, ${cz}])`);
                    push(`      cube([${cutDepth}, ${dim.w}, ${dim.h}]);`);
                    break;
                }
                case "right": {
                    // Right wall sits at X = outerL - wall
                    const cx = outerL - wall - 1;
                    const cy = wall + pos - dim.w / 2;
                    const cz = wall + hOff;
                    push(`    translate([${cx}, ${cy}, ${cz}])`);
                    push(`      cube([${cutDepth}, ${dim.w}, ${dim.h}]);`);
                    break;
                }
                default:
                    push(`    // Unknown side "${port.side}" — skipped`);
            }
        });
        push(``);
    }

    // Bottom vents (cut through the floor)
    if (vents) {
        push(`    // ----- Ventilation slots (bottom) -----`);
        push(`    add_vents();`);
    }

    push(`  } // end difference`);
    push(``);

    // Screw posts (added inside the box, not subtracted)
    if (screw_posts > 0) {
        push(`  // ----- Screw posts -----`);
        push(`  add_screw_posts();`);
    }

    push(`}`);
    push(``);

    // ── create_lid module ──────────────────────────────────────────────────
    push(`// ----- Lid -----`);
    push(`module create_lid() {`);
    push(`  lid_h = wall;`);
    push(`  // Place lid next to the box for easy viewing`);
    push(`  translate([outer_l + 10, 0, 0]) {`);
    push(`    difference() {`);
    push(`      union() {`);
    push(`        // Flat plate`);
    push(`        cube([outer_l, outer_w, lid_h]);`);
    push(``);
    push(`        // Inner lip (keeps lid aligned)`);
    push(`        translate([wall + clearance, wall + clearance, lid_h])`);
    push(`          difference() {`);
    push(`            cube([inner_l - clearance * 2, inner_w - clearance * 2, lid_h]);`);
    push(`            translate([wall/2, wall/2, -0.5])`);
    push(`              cube([inner_l - clearance * 2 - wall, inner_w - clearance * 2 - wall, lid_h + 1]);`);
    push(`          }`);
    push(`      }`);

    if (screw_posts > 0) {
        push(``);
        push(`      // Screw through-holes in lid`);
        push(`      add_lid_screw_holes();`);
    }

    push(`    }`);
    push(`  }`);
    push(`}`);
    push(``);

    // ── add_screw_posts module ─────────────────────────────────────────────
    const postR = 4;
    const holeR = 1.5;
    const numPosts = Math.min(screw_posts || 0, 4);

    push(`// ----- Screw posts (corner cylinders with pilot holes) -----`);
    push(`module add_screw_posts() {`);
    push(`  post_r = ${postR};`);
    push(`  hole_r = ${holeR};`);
    push(`  positions = [`);
    push(`    [wall + post_r,         wall + post_r,         wall],`);
    push(`    [outer_l - wall - post_r, wall + post_r,         wall],`);
    push(`    [wall + post_r,         outer_w - wall - post_r, wall],`);
    push(`    [outer_l - wall - post_r, outer_w - wall - post_r, wall]`);
    push(`  ];`);
    push(`  for (i = [0 : ${numPosts - 1}]) {`);
    push(`    translate(positions[i])`);
    push(`      difference() {`);
    push(`        cylinder(h = inner_h, r = post_r);`);
    push(`        translate([0, 0, 2])`);
    push(`          cylinder(h = inner_h + 1, r = hole_r);`);
    push(`      }`);
    push(`  }`);
    push(`}`);
    push(``);

    // ── add_lid_screw_holes module ─────────────────────────────────────────
    push(`// ----- Lid screw through-holes -----`);
    push(`module add_lid_screw_holes() {`);
    push(`  post_r = ${postR};`);
    push(`  hole_r = ${holeR + 0.3};  // slightly larger for clearance`);
    push(`  positions = [`);
    push(`    [wall + post_r,         wall + post_r,         -1],`);
    push(`    [outer_l - wall - post_r, wall + post_r,         -1],`);
    push(`    [wall + post_r,         outer_w - wall - post_r, -1],`);
    push(`    [outer_l - wall - post_r, outer_w - wall - post_r, -1]`);
    push(`  ];`);
    push(`  for (i = [0 : ${numPosts - 1}]) {`);
    push(`    translate(positions[i])`);
    push(`      cylinder(h = wall * 2 + 2, r = hole_r);`);
    push(`  }`);
    push(`}`);
    push(``);

    // ── add_vents module ───────────────────────────────────────────────────
    push(`// ----- Ventilation slots in the bottom floor -----`);
    push(`module add_vents() {`);
    push(`  vent_w   = 2;`);
    push(`  vent_gap = 4;`);
    push(`  margin   = wall + 8;  // stay away from edges`);
    push(`  for (x = [margin : vent_gap : outer_l - margin]) {`);
    push(`    translate([x, wall + inner_w * 0.2, -1])`);
    push(`      cube([vent_w, inner_w * 0.6, wall + 2]);`);
    push(`  }`);
    push(`}`);
    push(``);

    // ── Render ─────────────────────────────────────────────────────────────
    push(`// ----- Render both parts -----`);
    push(`create_box();`);
    push(`create_lid();`);
    push(``);

    return lines.join("\n");
}

module.exports = { generateSCAD };
