// =============================================================================
// cadGenerator.js â€” Parametric Enclosure Engine
// Upgraded for Engineering Accuracy & Modular SCAD Output
// =============================================================================

function generateSCAD(plan) {
    const {
        dimensions: dim,
        wall_thickness: wall,
        tolerance: tol,
        pcb_mounting: pcb,
        ports,
        ventilation: vent,
        lid,
    } = plan;

    const outerL = dim.length + wall * 2;
    const outerW = dim.width + wall * 2;
    const outerH = dim.height + wall;

    let scad = `
// =============================================
// PARAMETRIC ENCLOSURE (Generated by EnclosureAI)
// =============================================

$fn = 64;

// --- GLOBAL PARAMETERS ---
inner_l = ${dim.length};
inner_w = ${dim.width};
inner_h = ${dim.height};
wall = ${wall};
tol = ${tol};

outer_l = inner_l + wall * 2;
outer_w = inner_w + wall * 2;
outer_h = inner_h + wall;

// --- MODULAR GENERATORS ---

module generate_case_body() {
    difference() {
        // Main Case shell
        cube([outer_l, outer_w, outer_h]);
        
        // Internal hollow space
        translate([wall, wall, wall])
        cube([inner_l, inner_w, inner_h + 1]);
        
        // Port cutouts
        generate_ports();
        
        // Ventilation
        if (${vent.enabled}) {
            generate_ventilation();
        }
    }
    
    // PCB Mounts
    if ("${pcb.type}" != "none") {
        generate_pcb_mounts();
    }
    
    // Screw Bosses (if using screw lid)
    if ("${lid.style}" == "screw") {
        generate_screw_bosses();
    }
}

module generate_ports() {
    ${ports.map(port => {
        let pw = 12; let ph = 8; // Defaults
        if (port.type === 'usb_c') { pw = 10; ph = 4; }
        if (port.type === 'hdmi') { pw = 16; ph = 6; }

        let tx = 0, ty = 0, tz = wall + port.pos_z;
        let sx = wall + 2, sy = wall + 2; // cut depth

        if (port.side === 'front') {
            tx = wall + port.pos_x - pw / 2;
            ty = -1;
            sy = wall + 2;
            sx = pw;
        } else if (port.side === 'back') {
            tx = wall + port.pos_x - pw / 2;
            ty = outer_w - wall - 1;
            sy = wall + 2;
            sx = pw;
        } else if (port.side === 'left') {
            tx = -1;
            ty = wall + port.pos_x - pw / 2;
            sx = wall + 2;
            sy = pw;
        } else if (port.side === 'right') {
            tx = outer_l - wall - 1;
            ty = wall + port.pos_x - pw / 2;
            sx = wall + 2;
            sy = pw;
        }

        return `translate([${tx}, ${ty}, ${tz}]) cube([${sx}, ${sy}, ${ph}]); // Port: ${port.type}`;
    }).join('\n    ')}
}

module generate_pcb_mounts() {
    h = ${pcb.standoff_height};
    dia = ${pcb.hole_dia + 2};
    hole = ${pcb.hole_dia / 2};
    
    // Default 4 corners standoff
    offset = 5;
    mount_pos = [
        [wall + offset, wall + offset, wall],
        [outer_l - wall - offset, wall + offset, wall],
        [wall + offset, outer_w - wall - offset, wall],
        [outer_l - wall - offset, outer_w - wall - offset, wall]
    ];
    
    for (p = mount_pos) {
        translate(p)
        difference() {
            cylinder(h = h, d = dia);
            translate([0, 0, 1]) cylinder(h = h + 1, r = hole);
        }
    }
}

module generate_screw_bosses() {
    // Corner bosses for lid screws
    boss_r = 4;
    for (x = [wall + boss_r, outer_l - wall - boss_r]) {
        for (y = [wall + boss_r, outer_w - wall - boss_r]) {
            translate([x, y, wall])
            difference() {
                cylinder(h = inner_h, r = boss_r);
                translate([0,0, inner_h/2]) cylinder(h = inner_h, r = 1.5);
            }
        }
    }
}

module generate_ventilation() {
    if ("${vent.style}" == "slots") {
        for (x = [wall + 10 : 5 : outer_l - wall - 10]) {
            translate([x, wall + inner_w*0.2, -1])
            cube([2, inner_w*0.6, wall + 2]);
        }
    }
}

module generate_lid() {
    lid_thickness = wall;
    translate([outer_l + 10, 0, 0]) {
        difference() {
            union() {
                // Main lid plate
                cube([outer_l, outer_w, lid_thickness]);
                
                // Lip overlap for print tolerance
                translate([wall + tol, wall + tol, lid_thickness])
                difference() {
                    cube([inner_l - tol*2, inner_w - tol*2, wall]);
                    translate([wall/2, wall/2, -1])
                    cube([inner_l - tol*2 - wall, inner_w - tol*2 - wall, wall + 2]);
                }
            }
            
            // Screw holes in lid
            if ("${lid.style}" == "screw") {
                boss_r = 4;
                for (x = [wall + boss_r, outer_l - wall - boss_r]) {
                    for (y = [wall + boss_r, outer_w - wall - boss_r]) {
                        translate([x, y, -1])
                        cylinder(h = lid_thickness + 2, r = 1.8);
                    }
                }
            }
        }
    }
}

// --- FINAL RENDER ---
generate_case_body();
generate_lid();
`;
    return scad;
}

module.exports = { generateSCAD };
